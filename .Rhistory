sessionInfo
sessionInfo()
version
q()
q()
q()
q()
ls()
# Load required libraries
library(SingleCellExperiment)
install.packages("singleCellExperiment")
library(slingshot)
install.packages("slingshot")
library(scater)
install.packages("scater")
# Load required libraries
library(SingleCellExperiment)
library(slingshot)
library(scater)
BiocManager::install("SingleCellExperiment")
install.packages("BiocManager")
install.packages("BiocManager")
BiocManager::install("SingleCellExperiment")
load(BiocManager)
library(BiocManager)
updateR()
library(installr)
updateR()
BiocManager::install("SingleCellExperiment")
version()
q()
library(installr)
updateR()
q()
q()
# Load required libraries
library(BiocManager)
BiocManager::install("singleCellExperiment")
# Load required libraries
install.packages("BiocManager")
install.packages("BiocManager")
install.packages("BiocManager")
library(BiocManager)
BiocManager::install(update = T, ask = F)
BiocManager::install(version = "3.19")
BiocManager::install("singleCellExperiment")
BiocManager::install("SingleCellExperiment")
library(SingleCellExperiment)
BiocManager::install("slingshot")
BiocManager::install("scater")
library(slingshot)
library(scater)
str(plus, max.level = 2)
# load data
plus <- readRDS("data/seurat_object")
setwd("~/GitHub/direct-conversion")
# load data
plus <- readRDS("data/seurat_object")
# load gene set preparation function
source("data/20220509 sctype function-1.R")
# load cell type annotation function
source("data/20220509 sctype function-2.R")
# DB file
db_ = "data/ScTypeDB_full.xlsx";
tissue = "Brain"
# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)
### set up Assigning cell type identity to clusters
### automatically assign cell types using ScType
### reference : https://github.com/IanevskiAleksandr/sc-type/
## input file : seurat_object.rds, ScTypeDB_full.xlsx
# load packages
library(openxlsx)
library(tidyverse)
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T)
# get scale.data
scale_data <- GetAssayData(plus, layer = "scale.data")
# calculate sctype_score
es.max <- sctype_score(scRNAseqData = scale_data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T)
# calculate sctype_score
es.max <- sctype_score(scRNAseqData = scale_data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)
# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)
# get scale.data
scale_data <- GetAssayData(plus, layer = "scale.data")
# calculate sctype_score
es.max <- sctype_score(scRNAseqData = scale_data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)
# 클러스터별로 병합
cL_results <- do.call("rbind", lapply(unique(plus@meta.data$seurat_clusters), function(cl) {
es.max.cl <- sort(rowSums(es.max[, rownames(plus@meta.data[plus@meta.data$seurat_clusters == cl, ])]), decreasing = TRUE)
head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(plus@meta.data$seurat_clusters == cl)), 10)
}))
# 가장 높은 점수의 세포 타입 선택
sctype_scores <- cL_results %>% group_by(cluster) %>% top_n(n = 1, wt = scores)
# 신뢰도가 낮은 클러스터를 "Unknown"으로 설정
sctype_scores$type[as.numeric(sctype_scores$scores) < sctype_scores$ncells / 4] <- "Unknown"
# We can also overlay the identified cell types on UMAP plot
plus@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)){
cl_type = sctype_scores[sctype_scores$cluster==j,];
plus@meta.data$customclassif[plus@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}
# Filter out "Unknown" cells
plus@meta.data$customclassif[plus@meta.data$customclassif == ""] <- "Unknown"
plus_filtered <- subset(plus, subset = customclassif != "Unknown")
# 클러스터에 세포 타입 이름 할당
new.cluster.ids <- c("Immature\nneurons", "Myofibroblasts", "Fibroblasts", "Unknown",
"Fibroblasts", "Neurons", "Neurons")
plus <- RenameIdents(plus_filtered, new.cluster.ids)
# 클러스터에 세포 타입 이름 할당
new.cluster.ids <- c("Immature\nneurons", "Myofibroblasts", "Fibroblasts", "Unknown",
"Fibroblasts", "Neurons", "Neurons")
names(new.cluster.ids) <- current.cluster.levels
# Print the current cluster levels
current.cluster.levels <- levels(plus)
plus <- RenameIdents(plus_filtered, new.cluster.ids)
# 클러스터에 세포 타입 이름 할당
new.cluster.ids <- c("Immature\nneurons", "Myofibroblasts", "Fibroblasts", "Unknown",
"Fibroblasts", "Neurons", "Neurons")
names(new.cluster.ids) <- current.cluster.levels
plus <- RenameIdents(plus_filtered, new.cluster.ids)
saveRDS(plus, "data/seurat_object2")
plus = readRDS("data/seurat_object2.rds")
plus = readRDS("data/seurat_object2")
str(plus, max.level = 2)
# counts 데이터 추출 및 병합
counts_shCtrl <- plus[["RNA"]]$counts.shCtrl
counts_shPTBP1 <- plus[["RNA"]]$counts.shPTBP1
counts <- cbind(counts_shCtrl, counts_shPTBP1)
class(counts)
dim(counts)
counts[1:5, 1:5]
# data (normalized) 데이터 추출 및 병합
data_shCtrl <- plus[["RNA"]]$data.shCtrl
data_shPTBP1 <- plus[["RNA"]]$data.shPTBP1
data <- cbind(data_shCtrl, data_shPTBP1)
class(data)
data[1:5, 1:5]
# SingleCellExperiment 객체 생성
sce <- SingleCellExperiment(
assays = list(
counts = counts,
logcounts = data
),
colData = plus@meta.data,
reducedDims = list(
PCA = Embeddings(plus, "pca"),
UMAP = Embeddings(plus, "umap")
)
)
# 활성 식별자 추가
sce$cell_type <- plus@active.ident
# scaling
sce <- logNormCounts(sce)  # 로그 정규화 (이미 수행되었다면 건너뛰기)
sce <- scater::runPCA(sce, exprs_values = "logcounts")  # PCA 실행
# Run Slingshot with specified start and end clusters
# 클러스터 레이블 업데이트 함수
update_cluster_labels <- function(label) {
if (label %in% c("GABAergic neurons", "Glutamatergic neurons")) {
return("Neurons")
} else {
return(label)
}
}
# SingleCellExperiment 객체의 클러스터 레이블 업데이트
sce$updated_customclassif <- sapply(sce$customclassif, update_cluster_labels)
# 업데이트된 고유 클러스터 확인
unique_clusters <- unique(sce$updated_customclassif)
print(unique_clusters)
# Slingshot 실행 (업데이트된 레이블 사용)
sds <- slingshot(sce, clusterLabels = 'updated_customclassif', reducedDim = 'UMAP',
start.clus = "Fibroblasts",
end.clus = c("Neurons", "Myofibroblasts", "Immature neurons"))
# 궤적 그리기
# UMAP 좌표 추출
umap_coords <- reducedDims(sce)$UMAP
# 데이터 프레임 생성
plot_data <- data.frame(
UMAP1 = umap_coords[,1],
UMAP2 = umap_coords[,2],
CellType = sce$updated_customclassif
)
# 색상 정의
cell_colors <- c("Neurons" = "blue", "Immature neurons" = "yellow",
"Myofibroblasts" = "green", "Fibroblasts" = "red")
# 궤적 색상 정의
trajectory_colors <- c("#FF9999", "#66B2FF", "#c0d84d")
# ggplot으로 그리기
p <- ggplot(plot_data, aes(x = UMAP1, y = UMAP2, color = CellType)) +
geom_point(size = 0.5, alpha = 0.6) +
scale_color_manual(values = cell_colors) +
theme_minimal() +
labs(title = "Cell Types with Trajectories")
curve_data <- slingCurves(sds)[[i]]$s[slingCurves(sds)[[i]]$ord, ]
# 궤적 추가
for (i in seq_along(slingCurves(sds))) {
curve_data <- slingCurves(sds)[[i]]$s[slingCurves(sds)[[i]]$ord, ]
# 종착점 클러스터 찾기
end_cluster <- slingLineages(sds)[[i]][length(slingLineages(sds)[[i]])]
# 종착점 클러스터의 중심점 찾기
end_cluster_cells <- which(sce$updated_customclassif == end_cluster)
end_point <- colMeans(umap_coords[end_cluster_cells,])
# 종착점까지의 거리 계산
distances <- sqrt(rowSums((curve_data - matrix(end_point, nrow = nrow(curve_data), ncol = 2, byrow = TRUE))^2))
# 종착점에 가장 가까운 점 찾기
closest_point <- which.min(distances)
# 종착점까지의 궤적만 그리기
p <- p + geom_path(data = data.frame(UMAP1 = curve_data[1:closest_point,1],
UMAP2 = curve_data[1:closest_point,2]),
aes(x = UMAP1, y = UMAP2),
color = trajectory_colors[i],
linewidth = 1,
alpha = 0.7)
}
p
########## 20240708 pseudotime vln plot
# load packages
library(ggplot2)
library(dplyr)
library(tidyr)
# Pseudotime 값 추출
pseudotime <- slingPseudotime(sds)
# 데이터 프레임 생성
plot_data <- data.frame(
Cell = rownames(pseudotime),
Trajectory1 = pseudotime[,1],
Trajectory2 = pseudotime[,2],
Trajectory3 = pseudotime[,3],
Cluster = sce$updated_customclassif
)
class(sds)
class(sds)
class(pseudotime)
dim(pseudotime)
head(pseudotime)
# 데이터 프레임 생성
plot_data <- data.frame(
Cell = rownames(pseudotime),
Trajectory1 = pseudotime[,1],
Trajectory2 = pseudotime[,2],
Trajectory3 = pseudotime[,3],
Cluster = sce$updated_customclassif
)
# 클러스터 색상 정의
cluster_colors <- c("Neurons" = "blue",
"Immature neurons" = "yellow",
"Myofibroblasts" = "green",
"Fibroblasts" = "red")
# Long 형식으로 변환
plot_data_long <- plot_data %>%
pivot_longer(cols = c(Trajectory1, Trajectory2, Trajectory3),
names_to = "Trajectory",
values_to = "Pseudotime")
dim(plot_data_long)
head(plot_data_long)
# NA 값 제거
plot_data_long <- plot_data_long %>% filter(!is.na(Pseudotime))
# Checking presence of clusters in trajectories
for (i in 1:3) {
traj_cells <- plot_data_long %>% filter(Trajectory == paste0("Trajectory", i))
print(unique(traj_cells$Cluster))
}
head(traj_cells)
range(plot_data_long$Pseudotime
)
# Check for non-finite values in Pseudotime
non_finite_rows <- plot_data_long %>% filter(!is.finite(Pseudotime))
print(non_finite_rows)
# Normalize pseudotime values within each trajectory
plot_data_long2 <- plot_data_long %>%
group_by(Trajectory) %>%
mutate(Pseudotime = scales::rescale(Pseudotime))
# Normalize pseudotime values within each trajectory
plot_data_long_scaled <- plot_data_long %>%
group_by(Trajectory) %>%
mutate(Pseudotime = scales::rescale(Pseudotime))
# Identify groups with fewer than two datapoints
group_counts <- plot_data_long_scaled %>%
group_by(Trajectory, Cluster) %>%
summarise(n = n(), .groups = 'drop')
group_counts
sparse_groups <- group_counts %>% filter(n < 2)
# Add dummy points for sparse groups
dummy_points <- sparse_groups %>%
rowwise() %>%
mutate(Pseudotime = mean(plot_data_long_scaled$Pseudotime, na.rm = TRUE)) %>%
select(Trajectory, Cluster, Pseudotime)
dummy_points
head(group_counts)
head(plot_data_long_scaled)
plot_data_long_scaled %>%
filter(Cluster == "Neurons" & Trajectory == "Trajectory1")
plot_data_long_scaled2 = plot_data_long_scaled %>%
filter(!(Cluster == "Neurons" & Trajectory == "Trajectory1"))
dim(plot_data_long_scaled)
dim(plot_data_long_scaled2)
# Violin plot with adjusted data
vp <- ggplot(plot_data_long_scaled2, aes(x = Pseudotime, y = Cluster, fill = Cluster)) +
geom_violin(scale = "width") +
facet_wrap(~Trajectory, scales = "free_x", drop = FALSE) +
theme_minimal() +
labs(title = "Pseudotime Distribution by Cluster and Trajectory",
x = "Pseudotime",
y = "Cluster") +
scale_fill_manual(values = cluster_colors) +  # 사용자 정의 색상 적용
theme(legend.position = "top",
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5))
print(vp)
q()
